function [teffAnnual,peeffAnnual] = propagateErrorWithMCforPEeffAndTeff(...
    nLocs,latsLocal,lonsLocal,fullpathRawDataDir,filenameNppDataset,arrayFlux)
% [teffAnnual,peeffAnnual] = propagateErrorWithMCforPEeffAndTeff(...
%     nLocs,latsLocal,lonsLocal,fullpathRawDataDir,filenameNppDataset,arrayFlux)

% PROPAGATEERRORWITHMCFORPEEFFANDTEFF Calculates average PEeff and Teff 100 
% to 1000 m and propagates error from POC flux data.
%
%   INPUT: 
%       nLocs              - number of locations
%       latsLocal          - list of latitudes for interpolation for NPP
%       lonsLocal          - list of longitudes for interpolation for NPP
%       fullpathRawDataDir - directory where the NPP datasets are stored
%       filenameNppDataset - name of the NPP dataset(s)
%       arrayFlux          - POC flux, with dimensions: 2 (zeu, zmeso) x 12 x nLocs x 2 (avg, err)
%
%   OUTPUT:
%       teffAnnual  - transfer efficiency 100 to 1000 m, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%       peeffAnnual - particle export efficiency
%                              
%   This script uses two external functions: 
%       generateMCparameters.m - from FileExchange
%       propagateErrorWithMC.m - from FileExchange
%
%   WRITTEN BY A. RUFAS, UNIVERISTY OF OXFORD
%   Anna.RufasBlanco@earth.ox.ac.uk
%
%   Version 1.0 - Completed 9 April 2024 
%   Version 2.0 - Completed 23 Jul 2024 
%
% =========================================================================
%%
% -------------------------------------------------------------------------
% PROCESSING STEPS
% -------------------------------------------------------------------------

%% Definitions

% Define efficiency function (for PEeff and Teff)
funcEfficiency = @(x) x(1)./x(2);

% Define parameters
% Default no. samples generated by the function 'generateMCparameters'
NUM_MONTE_CARLO_SAMPLES = 1e5; 

% Define output arrays
teffMonthly = NaN(12,nLocs,5); % 3rd dimension: 1=median, 2=upp CI, 3=low CI, 4=max, 5=min
teffMonthly_mcvals = NaN(12,nLocs,NUM_MONTE_CARLO_SAMPLES);
teffAnnual = NaN(nLocs,5);
nNppAlgos = length(filenameNppDataset);
peeffMonthly = NaN(12,nLocs,nNppAlgos,3); % 4th dimension: 1=median, 2=upp CI, 3=low CI
peeffMonthly_mcvals = NaN(12,nLocs,nNppAlgos,NUM_MONTE_CARLO_SAMPLES);
peeffAnnual = NaN(nLocs,5); % 5th dimension: 1=median, 2=upp CI, 3=low CI, 4=max, 5=min

% Get local NPP (mg C m-2 d-1) for PEeff calculations
% [nppAvg,nppErr] = extractLocalNPP(nLocs,latsLocal,lonsLocal,...
%     fullpathRawDataDir,filenameNppDataset);

%% Calculate monthly averages 

fprintf('\nStart monthly calculations of Teff and PEeff...')

for iLoc = 1:nLocs 
    for iMonth = 1:12
        
%         % Calculate PEeff
%         for iNppAlgo = 1:nNppAlgos
%             if (~isnan(arrayFlux(1,iMonth,iLoc,1)) && ~isnan(nppAvg(iMonth,iLoc,iNppAlgo)))  
%                 A = generateMCparameters('gaussian',[arrayFlux(1,iMonth,iLoc,1),...
%                     arrayFlux(1,iMonth,iLoc,2)],'plot',false);
%                 B = generateMCparameters('gaussian',[nppAvg(iMonth,iLoc,iNppAlgo),...
%                     nppErr(iMonth,iLoc,iNppAlgo)],'plot',false);
% 
%                 % Error propagation using Monte Carlo method for a quotient 
%                 % becomes problematic when the denominator is smaller than 
%                 % the numerator
%                 [A,B] = checkForSorting(A,B); % to ensure B > A 
% 
%                 [midval_peeff,ci_peeff,funvals_peeff] = propagateErrorWithMC(funcEfficiency,[A;B],'plot',false);  
%                 peeffMonthly_mcvals(iMonth,iLoc,iNppAlgo,:) = funvals_peeff;
%                 peeffMonthly(iMonth,iLoc,iNppAlgo,1) = midval_peeff;
%                 peeffMonthly(iMonth,iLoc,iNppAlgo,2) = ci_peeff(2);
%                 peeffMonthly(iMonth,iLoc,iNppAlgo,3) = ci_peeff(1);
%                 peeffMonthly(iMonth,iLoc,iNppAlgo,4) = max(funvals_peeff);
%                 peeffMonthly(iMonth,iLoc,iNppAlgo,5) = min(funvals_peeff);
%             end
%         end % iNppAlgo

        % Calculate Teff
        if (~isnan(arrayFlux(2,iMonth,iLoc,1)) > 0 && ~isnan(arrayFlux(1,iMonth,iLoc,1)))  
            A = generateMCparameters('gaussian',[arrayFlux(2,iMonth,iLoc,1),...
                arrayFlux(2,iMonth,iLoc,2)],'plot',false);
            B = generateMCparameters('gaussian',[arrayFlux(1,iMonth,iLoc,1),...
                arrayFlux(2,iMonth,iLoc,2)],'plot',false);

            [A,B] = checkForSorting(A,B); % to ensure B > A 

            [midval_teffzeu,ci_teffzeu,funvals_teffzeu] = propagateErrorWithMC(funcEfficiency,[A;B],'plot',false);  
            ci_teffzeu(isnan(ci_teffzeu)) = 0; % when it goes beyond lower limit value of 0
            teffMonthly_mcvals(iMonth,iLoc,:) = funvals_teffzeu;
            teffMonthly(iMonth,iLoc,1) = midval_teffzeu;
            teffMonthly(iMonth,iLoc,2) = ci_teffzeu(2);
            teffMonthly(iMonth,iLoc,3) = ci_teffzeu(1);
            teffMonthly(iMonth,iLoc,4) = max(funvals_teffzeu);
            teffMonthly(iMonth,iLoc,5) = min(funvals_teffzeu);
   
        end
      
    end % iMonth
end % iLoc

fprintf('\n...done.\n')

%% Calculate annual averages

fprintf('\nStart annual calculations of Teff and PEeff...')

for iLoc = 1:nLocs
    
%     % Pool all PEeff samples
%     peeffLocalSamples = squeeze(peeffMonthly_mcvals(:,iLoc,:,:));
%     peeffLocalSamples = reshape(peeffLocalSamples,[],1);
%     iNonNan = ~isnan(peeffLocalSamples(:));
%     if (sum(iNonNan) > 0)
%         [midval_peeff,ci_peeff,funvals_peeff] = propagateErrorWithMC(@mean,peeffLocalSamples(iNonNan)','plot',false);
%         peeffAnnual(iLoc,1) = midval_peeff;
%         peeffAnnual(iLoc,2) = ci_peeff(2);
%         peeffAnnual(iLoc,3) = ci_peeff(1);
%         peeffAnnual(iLoc,4) = max(funvals_peeff);
%         peeffAnnual(iLoc,5) = min(funvals_peeff);
%     end

    % Pool all Teff samples
    teffLocalSamples = squeeze(teffMonthly_mcvals(:,iLoc,:));
    teffLocalSamples = reshape(teffLocalSamples,[],1);
    iNonNan = ~isnan(teffLocalSamples(:));
    if (sum(iNonNan) > 0)
        [midval_teff,ci_teff,funvals_teff] = propagateErrorWithMC(@mean,teffLocalSamples(iNonNan)','plot',false);
        ci_teff(isnan(ci_teff)) = 0;
        teffAnnual(iLoc,1) = midval_teff;
        teffAnnual(iLoc,2) = ci_teff(2);
        teffAnnual(iLoc,3) = ci_teff(1);
        teffAnnual(iLoc,4) = max(funvals_teff);
        teffAnnual(iLoc,5) = min(funvals_teff);
    end

    fprintf('\nLocation %d',iLoc)
%     fprintf('\nThe estimated PEeff is %4.3f, with std bounds %4.3f to %4.3f',peeffAnnual(iLoc,1),peeffAnnual(iLoc,2),peeffAnnual(iLoc,3))
    fprintf('\nThe estimated Teff is %4.3f, with std bounds %4.3f to %4.3f',teffAnnual(iLoc,1),teffAnnual(iLoc,2),teffAnnual(iLoc,3))

end % iLoc

fprintf('\n...done.\n')

%%
% -------------------------------------------------------------------------
% LOCAL FUNCTIONS
% -------------------------------------------------------------------------

% *************************************************************************

function [A,B] = checkForSorting(A,B)

% Ensure B is greater than A. Each entry in B, B(i), must be larger than
% the corresponding entry in A, A(i). If it's not the case, we want to
% replace B(i) by the next entry in B that is larger than A(i).

% Get rid of negative values
A(A<0) = min(A(A>0));
B(B<0) = min(B(B>0));

for i = 1:length(A)
    if B(i) <= A(i)
        % Find the next entry in B that is larger than A(i)
        C = B(i:end);
        largerIndxs = find(C > A(i)); 
        if ~isempty(largerIndxs)
            B(i) = C(largerIndxs(1));
        % If no indexes are found with the above method, search all entries 
        % in B (instead of just B > B(i))    
        elseif isempty(largerIndxs)
            largerIndxs = find(B > A(i)); 
            if ~isempty(largerIndxs)
                B(i) = B(largerIndxs(1));
            % If there is no entry in B larger than A(i), set A(i) to the 
            % maximum value found in B   
            elseif isempty(largerIndxs)
                A(i) = max(B(i));
            end
        end
    end
end

end % checkForSorting

% *************************************************************************

function [nppAvg,nppErr] = extractLocalNPP(nLocs,latsLocal,lonsLocal,...
    fullpathRawDataDir,filenameNppDataset)

nNppAlgos = length(filenameNppDataset);
nppAvg = zeros(12,nLocs,nNppAlgos); % mg C m-2 d-1
nppErr = zeros(12,nLocs,nNppAlgos); % mg C m-2 d-1

for iNppAlgo = 1:nNppAlgos

    load(strcat(fullpathRawDataDir,filenameNppDataset{iNppAlgo}),...
        'npp_avg','npp_lat','npp_lon','npp_err') % mg C m-2 d-1

    % Create grid for interpolation (data extraction)
    [Xpp, Ypp, Tpp] = ndgrid(npp_lat, npp_lon, (1:12)');
    Favg = griddedInterpolant(Xpp, Ypp, Tpp, npp_avg);
    Ferr = griddedInterpolant(Xpp, Ypp, Tpp, npp_err);
    
    % Extract local data
    for iLoc = 1:nLocs
        [qX, qY, qT] = ndgrid(latsLocal(iLoc), lonsLocal(iLoc), (1:12)'); 
        qNppAvg = squeeze(Favg(qX, qY, qT)); 
        qNppErr = squeeze(Ferr(qX, qY, qT));
        % Zero entries must be set to the min value in the array so that we 
        % don't have null NPP
        qNppAvg(qNppAvg==0) = min(npp_avg(npp_avg > 0),[],'all'); 
        qNppErr(qNppErr==0) = min(npp_err(npp_err > 0),[],'all');
        nppAvg(:,iLoc,iNppAlgo) = qNppAvg;
        nppErr(:,iLoc,iNppAlgo) = qNppErr;
    end
    
    % Good to clear before loading the next dataset
    clear npp_avg npp_err npp_lat npp_lon
    
end

end % extractLocalNPP

% *************************************************************************

end