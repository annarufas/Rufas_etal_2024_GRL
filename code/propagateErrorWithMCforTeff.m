function [teffAnnual,teffMonthly] = propagateErrorWithMCforTeff(arrayFlux,isMeansOfMeans)

% PROPAGATEERRORWITHMCFORTEFF Calculates average Teff and propagates error 
% from POC flux data.
%
%   INPUT:
%       arrayFlux      - POC flux array, with dimensions: 
%                           isMeansOfMeans=1: 2 (base zeu, base zmeso) x 12 x nLocs x 2 (avg, err)
%                           isMeansOfMeans=0: 2 (base zeu, base zmeso) x nLocs x 2 (avg, err)
%       isMeansOfMeans - Boolean indicating whether to calculate the metrics as the 
%                        mean of monthly averages or from annual POC flux values.
%
%   OUTPUT:
%       teffAnnual  - transfer efficiency, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%       teffMonthly - transfer efficiency, with dimensions: nLocs x 12 x 5 (median, uppCI, lowCI, max, min)
%                              
%   This script uses two external functions: 
%       generateMCparameters.m - from FileExchange
%       propagateErrorWithMC.m - from FileExchange
%
%   WRITTEN BY A. RUFAS, UNIVERISTY OF OXFORD
%   Anna.RufasBlanco@earth.ox.ac.uk
%
%   Version 1.0 - Completed 23 Oct 2024 
%
% =========================================================================
%%
% -------------------------------------------------------------------------
% PROCESSING STEPS
% -------------------------------------------------------------------------

%% Definitions

% Define efficiency function
funcEfficiency = @(x) x(1)./x(2);

% Define parameters
NUM_MONTE_CARLO_SAMPLES = 1e5; % default no. samples generated by the function 'generateMCparameters'

% Get number of locations
if (ndims(arrayFlux) == 4) % monthly values
    nLocs = size(arrayFlux,3);
elseif (ndims(arrayFlux) == 3) % annual values
    nLocs = size(arrayFlux,2);
end

% Define output arrays
if isMeansOfMeans
    teffMonthly        = NaN(nLocs,12,5); % 3rd dim: 1=median, 2=upp CI, 3=low CI, 4=max, 5=min
    teffMonthly_mcvals = NaN(nLocs,12,NUM_MONTE_CARLO_SAMPLES);
    teffAnnual         = NaN(nLocs,5);
else
    teffMonthly        = []; 
    teffAnnual         = NaN(nLocs,5); % 2nd dim: 1=median, 2=upp CI, 3=low CI, 4=max, 5=min
    teffAnnual_mcvals  = NaN(nLocs,NUM_MONTE_CARLO_SAMPLES);
end

%% Calculate annual averages 

if isMeansOfMeans % from means of monthly metrics

    fprintf('\nStart monthly calculations of Teff...')

    for iLoc = 1:nLocs 
        for iMonth = 1:12

            if (~isnan(arrayFlux(2,iMonth,iLoc,1)) > 0 && ~isnan(arrayFlux(1,iMonth,iLoc,1)))  
                A = generateMCparameters('gaussian',[arrayFlux(2,iMonth,iLoc,1),...
                    arrayFlux(2,iMonth,iLoc,2)],'plot',false); % at base mesopelagic zone
                B = generateMCparameters('gaussian',[arrayFlux(1,iMonth,iLoc,1),...
                    arrayFlux(1,iMonth,iLoc,2)],'plot',false); % at base euphotic zone

                [A,B] = checkForSorting(A,B); % to ensure B (base euphotic zone POC flux value) > A (base mesopelagic zone POC flux value)
      
                [midval_teffzeu,ci_teffzeu,funvals_teffzeu] = propagateErrorWithMC(...
                    funcEfficiency,[A;B],'plot',false);  
                ci_teffzeu(isnan(ci_teffzeu)) = 0; % when it goes beyond lower limit value of 0
                
                % Save output metrics
                teffMonthly_mcvals(iLoc,iMonth,:) = funvals_teffzeu;
                teffMonthly(iLoc,iMonth,1) = midval_teffzeu;
                teffMonthly(iLoc,iMonth,2) = ci_teffzeu(2);
                teffMonthly(iLoc,iMonth,3) = ci_teffzeu(1);
                teffMonthly(iLoc,iMonth,4) = max(funvals_teffzeu);
                teffMonthly(iLoc,iMonth,5) = min(funvals_teffzeu);

            end
        end % iMonth
    end % iLoc

    fprintf('\n...done.\n')
    fprintf('\nStart annual calculations of Teff...')

    for iLoc = 1:nLocs

        % Pool all Teff samples
        teffLocalSamples = squeeze(teffMonthly_mcvals(iLoc,:,:));
        teffLocalSamples = reshape(teffLocalSamples,[],1);
        iNonNan = ~isnan(teffLocalSamples(:));
        if (sum(iNonNan) > 0)
            [midval_teff,ci_teff,funvals_teff] = propagateErrorWithMC(...
                @mean,teffLocalSamples(iNonNan)','plot',false);
            ci_teff(isnan(ci_teff)) = 0;
            
            % Save output metrics
            teffAnnual(iLoc,1) = midval_teff;
            teffAnnual(iLoc,2) = ci_teff(2);
            teffAnnual(iLoc,3) = ci_teff(1);
            teffAnnual(iLoc,4) = max(funvals_teff);
            teffAnnual(iLoc,5) = min(funvals_teff);
        end

        fprintf('\nLocation %d',iLoc)
        fprintf('\nThe estimated Teff is %4.3f, with CI bounds %4.3f to %4.3f',...
            teffAnnual(iLoc,1),teffAnnual(iLoc,2),teffAnnual(iLoc,3))

    end % iLoc

    fprintf('\n...done.\n')

else % from annual POC flux values
    
    for iLoc = 1:nLocs

        if (~isnan(arrayFlux(2,iLoc,1)) > 0 && ~isnan(arrayFlux(1,iLoc,1)))  
            A = generateMCparameters('gaussian',[arrayFlux(2,iLoc,1),...
                arrayFlux(2,iLoc,2)],'plot',false); % at base mesopelagic zone
            B = generateMCparameters('gaussian',[arrayFlux(1,iLoc,1),...
                arrayFlux(1,iLoc,2)],'plot',false); % at base euphotic zone

            [A,B] = checkForSorting(A,B); % to ensure B (base euphotic zone POC flux value) > A (base mesopelagic zone POC flux value)

            [midval_teffzeu,ci_teffzeu,funvals_teffzeu] = propagateErrorWithMC(...
                funcEfficiency,[A;B],'plot',false);  
            ci_teffzeu(isnan(ci_teffzeu)) = 0; % when it goes beyond lower limit value of 0, set to 0
            
            % Save output metrics
            teffAnnual_mcvals(iLoc,:) = funvals_teffzeu;
            teffAnnual(iLoc,1) = midval_teffzeu;
            teffAnnual(iLoc,2) = ci_teffzeu(2);
            teffAnnual(iLoc,3) = ci_teffzeu(1);
            teffAnnual(iLoc,4) = max(funvals_teffzeu);
            teffAnnual(iLoc,5) = min(funvals_teffzeu);

        end

        fprintf('\nLocation %d',iLoc)
        fprintf('\nThe estimated Teff is %4.3f, with CI bounds %4.3f to %4.3f',...
            teffAnnual(iLoc,1),teffAnnual(iLoc,3),teffAnnual(iLoc,2))

    end % iLoc
    
end

%%
% -------------------------------------------------------------------------
% LOCAL FUNCTIONS
% -------------------------------------------------------------------------

% *************************************************************************

function [A,B] = checkForSorting(A,B)

% Ensure B (base euphotic) is greater than A (base mesopelagic). Each entry 
% in B, B(i), must be larger than the corresponding entry in A, A(i). If 
% it's not the case, we want to replace B(i) by the next entry in B that is 
% larger than A(i).

% Get rid of negative values
A(A<0) = min(A(A>0));
B(B<0) = min(B(B>0));

for i = 1:length(A)
    if B(i) <= A(i)
        % Find the next entry in B that is larger than A(i)
        C = B(i:end);
        largerIndxs = find(C > A(i)); 
        if ~isempty(largerIndxs)
            B(i) = C(largerIndxs(1));
        % If no indexes are found with the above method, search all entries 
        % in B (instead of just B > B(i))    
        elseif isempty(largerIndxs)
            largerIndxs = find(B > A(i)); 
            if ~isempty(largerIndxs)
                B(i) = B(largerIndxs(1));
            % If there is no entry in B larger than A(i), set A(i) to the 
            % maximum value found in B   
            elseif isempty(largerIndxs)
                A(i) = max(B(:));
            end
        end
    end
end

end % checkForSorting

% *************************************************************************

end