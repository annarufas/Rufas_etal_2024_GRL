function [martinbAnnual,zstarAnnual,martinbMonthly_gof,zstarMonthly_gof] =... 
    propagateErrorWithMCforMartinbAndZstar(nLocs,arrayDepths,arrayFlux)

% PROPAGATEERRORWITHMCFORMARTINBANDZSTAR Calculates average Martin's b and
% z* and propagates error from POC flux data.
%
%   INPUT: 
%       nLocs       - number of locations
%       arrayDepths - depths of POC flux
%       arrayFlux   - POC flux, with dimensions: depths x 12 months x nLocs x 2 (avg, err)
%
%   OUTPUT:
%       martinbAnnual - Martin's b coefficient, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%       zstarAnnual   - remineralisation length scale coefficient, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%                              
%   This script uses three external functions: 
%       defineFittypesForPocFluxAttenuationCurves.m - custom function
%       generateMCparameters.m  - from FileExchange
%       propagateErrorWithMC.m  - from FileExchange
%
%   WRITTEN BY A. RUFAS, UNIVERISTY OF OXFORD
%   Anna.RufasBlanco@earth.ox.ac.uk
%
%   Version 1.0 - Completed 6 Jun 2024 
%
% =========================================================================
%%
% -------------------------------------------------------------------------
% PROCESSING STEPS
% -------------------------------------------------------------------------

% To calculate the uncertainty associated to b and z*, it is necessary to
% propagate the error through the fit while considering the uncertainty in 
% the POC flux observations. Since it's not possible to account for both 
% sources of uncertainty using the 'fittype' and 'worstcase' functions,
% we have opted to perform Monte Carlo sampling across the variable space 
% created by the POC flux error. For each sample, we calculate b and z* 
% and calculate the mean and standard deviation of the ensamble. The annual 
% metrics are calculated as the ensemble of the monthly metrics.
    
%% Definitions

% Define functions to solve for b and z*
[fitMartinCurve,fitExpCurve] = defineFittypesForPocFluxAttenuationCurves();

% Define parameters
% No. times to perform random sampling for the calculation of b and z*.
% Set it to a high value.
NUM_SAMPLES = 1e3;
% Default no. samples generated by the function 'generateMCparameters'
NUM_MONTE_CARLO_SAMPLES = 1e5; 

% Define output arrays
martinbMonthly        = NaN(nLocs,12,3); % 3rd dimension: 1=media, 2=CI upp, 3=CI low
zstarMonthly          = NaN(size(martinbMonthly));
martinbMonthly_gof    = NaN(nLocs,12,NUM_SAMPLES); % to save fitted goodness of fit (GOF)
zstarMonthly_gof      = NaN(size(martinbMonthly_gof));
martinbMonthly_mcvals = NaN(nLocs,12,NUM_MONTE_CARLO_SAMPLES); 
zstarMonthly_mcvals   = NaN(size(martinbMonthly_mcvals));
martinbAnnual         = NaN(nLocs,5); % 5th dimension: 1=median, 2=CI upp, 3=CI low, 4=max, 5=min
zstarAnnual           = NaN(size(martinbAnnual));

%% Calculations
% The following loop takes time...

for iLoc = 1:nLocs
    
    fprintf('\nLocation %d',iLoc)
    
    % .....................................................................
    
    % Monthly calculations
    fprintf('\nStart monthly calculations of b and z*...')
    
    for iMonth = 1:12
        disp('Month')
        disp(iMonth)
        
        profileFlux_mean = arrayFlux(:,iMonth,iLoc,1); % mg C m-2 d-1
        profileDepths = arrayDepths(:,iMonth,iLoc); % m
        
        % Only proceed if (i) there are flux data and (ii) the first depth 
        % is < 200 m
        
        if (sum(~isnan(profileFlux_mean)) > 0 && profileDepths(1) <= 200)

            profileFlux_neterror = arrayFlux(:,iMonth,iLoc,2);
            nFluxPoints = sum(~isnan(profileDepths));
            
            % The following is a form of latin hypercube sampling. By 
            % sampling the space created by the mean +/- err of flux at 
            % each depth point, it generates the parameter sampling space 
            % (MC parameters = paramMatrixFlux) that will be used to 
            % calculate b and z*
            paramMatrixFlux = NaN(nFluxPoints,NUM_SAMPLES);
            for iFluxPoint = 1:nFluxPoints
                if (~isnan(profileFlux_mean(iFluxPoint)))
                    paramMatrixFlux(iFluxPoint,:) =... 
                        normrnd(profileFlux_mean(iFluxPoint),...
                        profileFlux_neterror(iFluxPoint),[1 NUM_SAMPLES]);
                    % Replace negative values with the min value larger
                    % than 0 in the string of values generated for that
                    % particular flux point
                    thisRow = paramMatrixFlux(iFluxPoint,:);
                    thisRow(thisRow<0) = min(thisRow(thisRow>0)); 
                    paramMatrixFlux(iFluxPoint,:) = thisRow;
                end
            end
            
            % .............................................................
            
            % Curve fitting starts here
            
            funvals_martinb = NaN(NUM_SAMPLES,3); % 1=median, 2=GOF, 3=CI
            funvals_zstar   = NaN(NUM_SAMPLES,3);
            
            for iSample = 1:NUM_SAMPLES
                f = paramMatrixFlux(:,iSample); 
                if (sum(~isnan(f)) > 0)
                    
                    z = profileDepths(1:nFluxPoints);
                    
                    % The fit function cannot take NaN values, remove them
                    iNonNan = ~isnan(z) & ~isnan(f);
                    f = f(iNonNan);
                    z = z(iNonNan);

                    % Proceed if there are data in the 1st position of the 
                    % POC flux vector and there are at least 3 data points 
                    % in the vertical
                    if (f(1) > 0 && size(f,1) >= 3) 

                        % Model fit
                        f0 = f(1);
                        z0 = z(1);
                        [fm,gofm] = fit(z,f,fitMartinCurve,'problem',{f0,z0},...
                            'Lower',0.1,'Upper',4,'StartPoint',0.09);  
                        [fe,gofe] = fit(z,f,fitExpCurve,'problem',{f0,z0},...
                            'Lower',50,'Upper',2000,'StartPoint',40); 

                        fmartin(1) = fm.b;
                        fmartin(2) = gofm.adjrsquare;
                        fexp(1) = fe.zstar;
                        fexp(2) = gofe.adjrsquare;

                        % Extract the 95% CI bounds of the fitted coefficients
                        coeffBoundsMartinb = confint(fm); 
                        coeffBoundsZstar = confint(fe); 

                        % Calculate std from 95% CI
                        n = length(f); % number of data points
                        fmartin(3) = ((max(coeffBoundsMartinb)-min(coeffBoundsMartinb))*sqrt(n))/3.92; 
                        fexp(3) = ((max(coeffBoundsZstar)-min(coeffBoundsZstar))*sqrt(n))/3.92;

                        % If GOF is below 0 or the b coeficient is negative
                        if (gofm.adjrsquare <= 0 || fm.b <= 0) 
                            fmartin(:) = NaN;
                        end
                        % If GOF is below 0 or z* is negative
                        if (gofe.adjrsquare <= 0 || fe.zstar <= 0) 
                            fexp(:) = NaN;
                        end  

                    else
                        fmartin = NaN(3,1);
                        fexp = NaN(3,1);
                    end
                    
                    funvals_martinb(iSample,:) = fmartin; 
                    funvals_zstar(iSample,:) = fexp;
                    
                end % checking if there are data
            end % iSample
            
            % Save GOF metrics
            martinbMonthly_gof(iLoc,iMonth,:) = funvals_martinb(:,2);
            zstarMonthly_gof(iLoc,iMonth,:) = funvals_zstar(:,2);
            
            % .............................................................

            % Error propagation using MC
            
%         % The following three methods produce similar results. We will
%         % use Method A as it gives us the chance to resample the
%         % Monte Carlo-generated samples to get rid of the NaNs.
%         % We cannot pass NaN values to the mean function, but we cannot
%         % pass either a b or z vector with NaN removed because it shortens
%         % the vector from the expected length of multiple of 10 (in our
%         % case, 1000) to a non-multiple of 10, and propagateErrorWithMC
%         % expects a vector with that length multiple of 10.
% 
%         % Method A
%         A = generateMCparameters('bootstrapDistribution',funvals_martinb(:,1));
%         [midval_martinb_1,ci_martinb_1,funvals_martinb_1] = propagateErrorWithMC(@mean,A','plot',false);
% 
%         % Method B
%         paramMatrixMartinb = NaN(nSamples,1e5); % 1e5 is the no. realisations that "generateMCparameters" uses
%         for iSample = 1:nSamples
%             if (~isnan(funvals_martinb(iSample,1)) && ~isnan(funvals_martinb(iSample,3)))
%                 paramMatrixMartinb(iSample,:) = generateMCparameters('gaussian',[funvals_martinb(iSample,1),funvals_martinb(iSample,3)],'plot',false);
%             end
%         end
%         iNonNanRows = find(all(~isnan(paramMatrixMartinb),2));
%         paramMatrixMartinb = paramMatrixMartinb(iNonNanRows,:); % crop the NaN rows
%         [midval_martinb_2,ci_martinb_2,funvals_martinb_2] = propagateErrorWithMC(@mean,paramMatrixMartinb,'plot',false);    
% 
%         % Method C
%         [midval_martinb_3,ci_martinb_3,funvals_martinb_3] = propagateErrorWithMC(@mean,funvals_martinb(:,1)','plot',false);

            % Before propagating error, we must remove 'unacceptable' values 
            % and resample (to regenerate a vector of length multiple of 10) 
            % by using the bootstrap method
            
            iAccVals = (~isnan(funvals_martinb(:,2)) & ~isinf(funvals_martinb(:,2))... 
                & funvals_martinb(:,2) > 0.10)... % GOF > 10%
                & funvals_martinb(:,1) > 0.10 & funvals_martinb(:,1) < 4 & funvals_martinb(:,3) < 10.*funvals_martinb(:,1);
            
            if (sum(iAccVals) >= 5) % 'bootstrapDistribution' needs at least 5 values
                funvals_resampled_martinb = generateMCparameters(...
                    'bootstrapDistribution',funvals_martinb(iAccVals,1));
                [midval_martinb,ci_martinb,funvals_monthly_martinb] =...
                    propagateErrorWithMC(@mean,funvals_resampled_martinb','plot',false);
            else
                disp('No reasonable values found for b')
                midval_martinb = 0;
                ci_martinb = [0, 0];
                funvals_monthly_martinb = zeros(1e5,1);
            end
                
            iAccVals = (~isnan(funvals_zstar(:,2)) & ~isinf(funvals_zstar(:,2))... 
                & funvals_zstar(:,2) > 0.10)... % GOF > 10%
                & funvals_zstar(:,1) > 50 & funvals_zstar(:,1) < 2000 & funvals_zstar(:,3) < 10.*funvals_zstar(:,1);
            
            if (sum(iAccVals) >= 5)% 'bootstrapDistribution' needs at least 5 values
                funvals_resampled_zstar = generateMCparameters(...
                    'bootstrapDistribution',funvals_zstar(iAccVals,1));
                [midval_zstar,ci_zstar,funvals_monthly_zstar] =... 
                    propagateErrorWithMC(@mean,funvals_resampled_zstar','plot',false);
            else
                disp('No reasonable values found for z*')
                midval_zstar = 0;
                ci_zstar = [0, 0];
                funvals_monthly_zstar = zeros(1e5,1);
            end
            
            martinbMonthly(iLoc,iMonth,1) = midval_martinb;
            martinbMonthly(iLoc,iMonth,2) = ci_martinb(2);
            martinbMonthly(iLoc,iMonth,3) = ci_martinb(1);
            martinbMonthly_mcvals(iLoc,iMonth,:) = funvals_monthly_martinb;
 
            zstarMonthly(iLoc,iMonth,1) = midval_zstar;
            zstarMonthly(iLoc,iMonth,2) = ci_zstar(2);
            zstarMonthly(iLoc,iMonth,3) = ci_zstar(1);
            zstarMonthly_mcvals(iLoc,iMonth,:) = funvals_monthly_zstar;

        end
        
    end % iMonth
    
    fprintf('\n...done.')
    
    % .....................................................................
    
    % Annual calculations
    fprintf('\nStart annual calculations of b and z*...')
    
    % Only calculate annual values if there are more than 2 months with data
    if (sum(nnz(martinbMonthly(iLoc,:,1))) >= 2)
    
        % We need to resample after getting rid of NaNs to exactly have a 
        % vector of length multiple of 10 (it is what propagateErrorWithMC expects).
        martinbLocalSamples = squeeze(martinbMonthly_mcvals(iLoc,:,:));
        martinbLocalSamples = reshape(martinbLocalSamples,[],1);
        iAccVals = (~isnan(martinbLocalSamples) & martinbLocalSamples > 0);

        if (sum(iAccVals) >= 5) % 'bootstrapDistribution' needs at least 5 values
            martinbLocalResampled = generateMCparameters(...
                'bootstrapDistribution',martinbLocalSamples(iAccVals));
            [midval_martinb,ci_martinb,funvals_local_martinb] =...
                propagateErrorWithMC(@mean,martinbLocalResampled','plot',false);
        else
            %disp('No reasonable values found for b')
            midval_martinb = NaN;
            ci_martinb = [NaN, NaN];
            funvals_local_martinb = NaN(1e5,1);
        end
    
    else    
        midval_martinb = NaN;
        ci_martinb = [NaN, NaN];
        funvals_local_martinb = NaN(1e5,1);
    end
 
    
    % Only calculate annual values if there are more than 2 months with data
    if (sum(nnz(zstarMonthly(iLoc,:,1))) >= 2)
    
        zstarLocalSamples = squeeze(zstarMonthly_mcvals(iLoc,:,:));
        zstarLocalSamples = reshape(zstarLocalSamples,[],1); % make sure it's a row vector
        iAccVals = (~isnan(zstarLocalSamples) & zstarLocalSamples > 0);

        if (sum(iAccVals) >= 5) % 'bootstrapDistribution' needs at least 5 values
            zstarLocalResampled = generateMCparameters(...
                'bootstrapDistribution',zstarLocalSamples(iAccVals));
            [midval_zstar,ci_zstar,funvals_local_zstar] =... 
                propagateErrorWithMC(@mean,zstarLocalResampled','plot',false);
        else
            %disp('No reasonable values found for z*')
            midval_zstar = NaN;
            ci_zstar = [NaN, NaN];
            funvals_local_zstar = NaN(1e5,1);
        end
        
    else
        midval_zstar = NaN;
        ci_zstar = [NaN, NaN];
        funvals_local_zstar = NaN(1e5,1);
    end
 
    martinbAnnual(iLoc,1) = midval_martinb;
    martinbAnnual(iLoc,2) = ci_martinb(2);
    martinbAnnual(iLoc,3) = ci_martinb(1);
    martinbAnnual(iLoc,4) = max(funvals_local_martinb);
    martinbAnnual(iLoc,5) = min(funvals_local_martinb);
    
    zstarAnnual(iLoc,1) = midval_zstar;
    zstarAnnual(iLoc,2) = ci_zstar(2);
    zstarAnnual(iLoc,3) = ci_zstar(1);
    zstarAnnual(iLoc,4) = max(funvals_local_zstar);
    zstarAnnual(iLoc,5) = min(funvals_local_zstar); 
            
    fprintf('\nThe estimated b is %4.3f, with std bounds %4.3f to %4.3f',martinbAnnual(iLoc,1),martinbAnnual(iLoc,3),martinbAnnual(iLoc,2))
    fprintf('\nThe estimated z* is %3.0f, with std bounds %3.0f to %3.0f',zstarAnnual(iLoc,1),zstarAnnual(iLoc,3),zstarAnnual(iLoc,2))
    fprintf('\n...done.\n')
    
end % iLoc

end
