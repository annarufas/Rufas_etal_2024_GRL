function [martinbAnnual,zstarAnnual,martinb_gof,zstar_gof] =... 
    propagateErrorWithMCforMartinbAndZstar(arrayDepths,arrayFlux,...
    isMeansOfMeans,isLogTransformed,isFluxNormalised,choiceZref)

% PROPAGATEERRORWITHMCFORMARTINBANDZSTAR Calculates average Martin's b and
% z* and propagates error from POC flux data.
%
%   INPUT: 
%       arrayDepths      - Depths of POC flux.
%       arrayFlux        - POC flux array, with dimensions: 
%                             isMeansOfMeans=1: values x 12 x nLocs x 2 (avg, err)
%                             isMeansOfMeans=0: values x nLocs x 2 (avg, err)
%       isMeansOfMeans   - Boolean indicating whether to calculate the metrics as the 
%                          mean of monthly averages or from annual POC flux values.
%       isLogTransformed - Boolean indicating whether to log-transform depth and POC 
%                          flux data before fitting b and z*.
%       isFluxNormalised - Boolean indicating whether to normalise POC flux
%                          to the value at zref.
%       choiceZref       - Boolean, where 1=closest value to 100, 2=zeu, 
%                          3=inflexion point.
%
%   OUTPUT:
%       martinbAnnual - Martin's b coefficient, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%       zstarAnnual   - remineralisation length scale coefficient, with dimensions: nLocs x 5 (median, uppCI, lowCI, max, min)
%                              
%   This script uses these external functions:
%       constructFilenameFitMetrics.m - custom function
%       samplePocFluxWithLH.m         - custom function
%       solveMartinbAndZstar.m        - custom function
%       generateMCparameters.m        - from FileExchange
%       propagateErrorWithMC.m        - from FileExchange
%
%   WRITTEN BY A. RUFAS, UNIVERISTY OF OXFORD
%   Anna.RufasBlanco@earth.ox.ac.uk
%
%   Version 1.0 - Completed 1 Nov 2024 
%
% =========================================================================
%%
% -------------------------------------------------------------------------
% PROCESSING STEPS
% -------------------------------------------------------------------------

% To calculate the uncertainty associated to b and z*, it is necessary to
% propagate the error through the fit while considering the uncertainty in 
% the POC flux measurements. Since it's not possible to account for both 
% sources of uncertainty using the 'fittype' and 'worstcase' functions,
% we have opted to perform Monte Carlo sampling across the variable space 
% created by the POC flux error. For each sample, we calculate b and z* 
% and calculate the mean and standard deviation of the ensamble.
    
%% Definitions

% Output filename for fits
filenameFitMetricsOutput = constructFilenameFitMetrics(...
    isMeansOfMeans,isLogTransformed,isFluxNormalised,choiceZref);

% Define parameters
NUM_SAMPLES = 1e3; % no. times to perform random sampling for the calculation of b and z* (set it high)
NUM_MONTE_CARLO_SAMPLES = 1e5; % default no. samples generated by the function 'generateMCparameters'

% Get number of locations
if (ndims(arrayFlux) == 4) % monthly values
    nLocs = size(arrayFlux,3);
elseif (ndims(arrayFlux) == 3) % annual values
    nLocs = size(arrayFlux,2);
end

% Define output arrays
if isMeansOfMeans
    martinbMonthly        = NaN(nLocs,12,5); % 3rd dim: 1=median, 2=CI upp, 3=CI low, 4=max, 5=min
    zstarMonthly          = NaN(size(martinbMonthly));
    martinb_gof           = NaN(nLocs,12,NUM_SAMPLES); % to save fitted goodness of fit (GOF)
    zstar_gof             = NaN(size(martinb_gof));
    martinbMonthly_mcvals = NaN(nLocs,12,NUM_MONTE_CARLO_SAMPLES); 
    zstarMonthly_mcvals   = NaN(size(martinbMonthly_mcvals));
    martinbAnnual         = NaN(nLocs,5); 
    zstarAnnual           = NaN(size(martinbAnnual));    
else
    martinbAnnual        = NaN(nLocs,5); % 5th dimension: 1=median, 2=CI upp, 3=CI low, 4=max, 5=min
    zstarAnnual          = NaN(size(martinbAnnual));
    martinbAnnual_mcvals = NaN(nLocs,NUM_MONTE_CARLO_SAMPLES);
    zstarAnnual_mcvals   = NaN(nLocs,NUM_MONTE_CARLO_SAMPLES);
    martinb_gof          = NaN(nLocs,NUM_SAMPLES); 
    zstar_gof            = NaN(size(martinb_gof));
end

%% Calculations

if isMeansOfMeans % from means of monthly metrics
    
    for iLoc = 1:nLocs
        fprintf('\nLocation %d',iLoc)

        % .................................................................

        fprintf('\nStart monthly calculations of b and z*...')

        for iMonth = 1:12
            fprintf('\nMonth num: %d', iMonth)
            
            profileFluxAvg   = arrayFlux(:,iMonth,iLoc,1); % mg C m-2 d-1
            profileFluxError = arrayFlux(:,iMonth,iLoc,2); % mg C m-2 d-1
            profileDepths    = arrayDepths(:,iMonth,iLoc); % m
            
            % Fit b and z* and propagate error from POC flux and fit
            [martinbMonthly(iLoc,iMonth,:),...
             martinbMonthly_mcvals(iLoc,iMonth,:),...
             martinb_gof(iLoc,iMonth,:),...
             zstarMonthly(iLoc,iMonth,:),...
             zstarMonthly_mcvals(iLoc,iMonth,:),...
             zstar_gof(iLoc,iMonth,:)] =...
                fitAndPropagateError(profileFluxAvg,profileFluxError,...
                profileDepths,isLogTransformed,NUM_SAMPLES,NUM_MONTE_CARLO_SAMPLES);
            
        end % iMonth
    
        fprintf('\n...done.')
    
        % .................................................................

        fprintf('\nStart annual calculations of b and z*...')

        if (sum(nnz(martinbMonthly(iLoc,:,1))) >= 2) % if there are >=2 months with data

            % Error propagation from monthly to annual averages using MC
            martinbLocalSamples = squeeze(martinbMonthly_mcvals(iLoc,:,:));
            martinbLocalSamples = reshape(martinbLocalSamples,[],1); % make sure it's a row vector
            [midval_martinb,ci_martinb,funvals_martinb] =... 
                errorPropagationWithMC(martinbLocalSamples,'b',NUM_MONTE_CARLO_SAMPLES);

            martinbAnnual(iLoc,1) = midval_martinb;
            martinbAnnual(iLoc,2) = ci_martinb(2);
            martinbAnnual(iLoc,3) = ci_martinb(1);
            martinbAnnual(iLoc,4) = max(funvals_martinb);
            martinbAnnual(iLoc,5) = min(funvals_martinb);

        end
        if (sum(nnz(zstarMonthly(iLoc,:,1))) >= 2) % if there are >=2 months with data

            % Error propagation from monthly to annual averages using MC
            zstarLocalSamples = squeeze(zstarMonthly_mcvals(iLoc,:,:));
            zstarLocalSamples = reshape(zstarLocalSamples,[],1); % make sure it's a row vector
            [midval_zstar,ci_zstar,funvals_zstar] =... 
                errorPropagationWithMC(zstarLocalSamples,'z*',NUM_MONTE_CARLO_SAMPLES);

            zstarAnnual(iLoc,1) = midval_zstar;
            zstarAnnual(iLoc,2) = ci_zstar(2);
            zstarAnnual(iLoc,3) = ci_zstar(1);
            zstarAnnual(iLoc,4) = max(funvals_zstar);
            zstarAnnual(iLoc,5) = min(funvals_zstar); 
            
        end

        fprintf('\nThe estimated b is %4.3f, with CI bounds %4.3f to %4.3f',...
            martinbAnnual(iLoc,1),martinbAnnual(iLoc,3),martinbAnnual(iLoc,2))
        fprintf('\nThe estimated z* is %3.0f, with CI bounds %3.0f to %3.0f',...
            zstarAnnual(iLoc,1),zstarAnnual(iLoc,3),zstarAnnual(iLoc,2))
        fprintf('\n...done.\n')

    end % iLoc
       
else % from annual POC flux values

    fprintf('\nStart annual calculations of b and z*...')

    for iLoc = 1:nLocs
        fprintf('\nLocation %d',iLoc)
        
        profileFluxAvg   = arrayFlux(:,iLoc,1); % mg C m-2 d-1
        profileFluxError = arrayFlux(:,iLoc,2); % mg C m-2 d-1
        profileDepths    = arrayDepths(:,iLoc); % m

        % Fit b and z* and propagate error from POC flux and fit
        [martinbAnnual(iLoc,:),...
         martinbAnnual_mcvals(iLoc,:),...
         martinb_gof(iLoc,:),...
         zstarAnnual(iLoc,:),...
         zstarAnnual_mcvals(iLoc,:),...
         zstar_gof(iLoc,:)] =...
            fitAndPropagateError(profileFluxAvg,profileFluxError,...
            profileDepths,isLogTransformed,NUM_SAMPLES,NUM_MONTE_CARLO_SAMPLES);

        fprintf('\nThe estimated b is %4.3f, with CI bounds %4.3f to %4.3f',...
            martinbAnnual(iLoc,1),martinbAnnual(iLoc,3),martinbAnnual(iLoc,2))
        fprintf('\nThe estimated z* is %3.0f, with CI bounds %3.0f to %3.0f',...
            zstarAnnual(iLoc,1),zstarAnnual(iLoc,3),zstarAnnual(iLoc,2))
        fprintf('\n...done.\n')

    end % iLoc

end

%% Save the fit metrics

if isMeansOfMeans   
    save(fullfile('.','data','processed',filenameFitMetricsOutput),...
        'martinbMonthly','zstarMonthly','martinb_gof','zstar_gof',...
        'martinbMonthly_mcvals','zstarMonthly_mcvals','martinbAnnual','zstarAnnual')
else  
    save(fullfile('.','data','processed',filenameFitMetricsOutput),...
        'martinbAnnual','zstarAnnual','martinb_gof','zstar_gof',...
        'martinbAnnual_mcvals','zstarAnnual_mcvals')
end

% =========================================================================
%%
% -------------------------------------------------------------------------
% LOCAL FUNCTIONS TO THIS SCRIPT
% -------------------------------------------------------------------------

function [martinbArray,martinbArray_mcvals,martinbArray_gof,...
    zstarArray,zstarArray_mcvals,zstarArray_gof] = fitAndPropagateError(...
    profileFluxAvg,profileFluxError,profileDepths,...
    isLogTransformed,NUM_SAMPLES,NUM_MONTE_CARLO_SAMPLES)

    % Initialise output arrays
    martinbArray        = NaN(1,5); % [value, upper CI, lower CI, max, min]
    martinbArray_mcvals = NaN(NUM_MONTE_CARLO_SAMPLES,1);
    martinbArray_gof    = NaN(NUM_SAMPLES,1);
    
    zstarArray          = NaN(1,5); % [value, upper CI, lower CI, max, min]
    zstarArray_mcvals   = NaN(NUM_MONTE_CARLO_SAMPLES,1);
    zstarArray_gof      = NaN(NUM_SAMPLES,1);
    
    % Only proceed if there are flux data and the first depth is <= 200 m
    if (sum(~isnan(profileFluxAvg)) > 0 && profileDepths(1) <= 200)

        % Randomly sample POC flux values from a normal distribution to
        % generate 'NUM_SAMPLES' POC flux profiles
        [paramMatrixFlux,fluxDepths] = samplePocFluxWithLH(profileFluxAvg,...
            profileFluxError,profileDepths,NUM_SAMPLES);

        % Calculate b and z* for each sample
        martinbModel = NaN(NUM_SAMPLES,3); % [value, GOF, std of the fit]
        zstarModel   = NaN(NUM_SAMPLES,3);
        for iSample = 1:NUM_SAMPLES
            fluxValues = paramMatrixFlux(:,iSample); 
            if (sum(~isnan(fluxValues)) > 0)  
                [martinbModel(iSample,:),zstarModel(iSample,:)] =...
                    solveMartinbAndZstar(isLogTransformed,fluxValues,fluxDepths);
            end
        end 

        % Error propagation using MC
        [midval_martinb,ci_martinb,funvals_martinb] =... 
            errorPropagationWithMC(martinbModel(:,1),'b',NUM_MONTE_CARLO_SAMPLES);
        [midval_zstar,ci_zstar,funvals_zstar] =... 
            errorPropagationWithMC(zstarModel(:,1),'z*',NUM_MONTE_CARLO_SAMPLES);
        
        % Save output metrics
        martinbArray(1)     = midval_martinb;
        martinbArray(2)     = ci_martinb(2);
        martinbArray(3)     = ci_martinb(1);
        martinbArray(4)     = max(funvals_martinb);
        martinbArray(5)     = min(funvals_martinb);
        martinbArray_mcvals = funvals_martinb;
        martinbArray_gof    = martinbModel(:,2);
        
        zstarArray(1)       = midval_zstar;
        zstarArray(2)       = ci_zstar(2);
        zstarArray(3)       = ci_zstar(1);
        zstarArray(4)       = max(funvals_zstar);
        zstarArray(5)       = min(funvals_zstar);
        zstarArray_mcvals   = funvals_zstar;
        zstarArray_gof      = zstarModel(:,2);
    
    end

end % fitAndPropagateError  

% *************************************************************************

function [midval,ci,funvals] = errorPropagationWithMC(coeffVals,coeffName,...
    NUM_MONTE_CARLO_SAMPLES)

    % Initialise output arrays
    midval  = NaN;
    ci      = [NaN, NaN];
    funvals = NaN(NUM_MONTE_CARLO_SAMPLES,1);
    
    iAccVals = (~isnan(coeffVals) & coeffVals > 0);

    if (sum(iAccVals) >= 5) % 'bootstrapDistribution' needs at least 5 values

        funvals_resampled = generateMCparameters('bootstrapDistribution',coeffVals(iAccVals));

        % Round each number to the 5th significant figure
        decimalPlaces = 5 - floor(log10(abs(funvals_resampled))) - 1;
        uniqueDecimalPlaces = unique(decimalPlaces);
        roundedFunvalsResampled = round(funvals_resampled, uniqueDecimalPlaces(1));

        % Find unique elements in 'roundedFunvalsResampled' and count them
        uniqueRoundedFunvalsResampled = unique(roundedFunvalsResampled);
        nUniqueFunvalsResampled = length(uniqueRoundedFunvalsResampled);

        % Only proceed if there are >5 different values in the resampled
        % vector
        if (nUniqueFunvalsResampled > 5)
            % This chunk of code is prone to error – when all values in
            % funvals_resampled are almost identical
            try
                [midval,ci,funvals] = propagateErrorWithMC(@mean,funvals_resampled','plot',false);
            catch ME
                % Set display format to avoid scientific notation
                format longG;
                % Display the error message
                disp('First 100 rows of funvals_resampled:');
                disp(funvals_resampled(1:min(100, end), :));
                disp('First 100 rows of coeffVals(iAccVals):');
                coeffAcc = coeffVals(iAccVals);
                disp(coeffAcc(1:min(100, end), :));
            end
        else
            fprintf('\nNo reasonable values found for %s\n', coeffName)
        end
    else
        fprintf('\nNo reasonable values found for %s\n', coeffName)
    end
   
% I've identified up to 3 different ways of propagating errors via MC (see 
% below). Above, I've used Method A as it gives us the chance to resample 
% the MC-generated samples to get rid of the NaNs. We cannot pass NaN values 
% to the @mean function, but we cannot pass either a b or z vector with 
% NaN removed because it shortens the vector from the expected length of 
% multiple of 10 (in our case, 1000) to a non-multiple of 10, and 
% propagateErrorWithMC expects a vector with that length multiple of 10. 
% Thus, before propagating error, resample the non-NaN values to regenerate 
% a vector of length multiple of 10 by using the bootstrap technique.
%
% Method A
% A = generateMCparameters('bootstrapDistribution',funvals_martinb(:,1));
% [midval_martinb_1,ci_martinb_1,funvals_martinb_1] = propagateErrorWithMC(@mean,A','plot',false);
% 
% Method B
% paramMatrixMartinb = NaN(nSamples,1e5); % 1e5 is the no. realisations that "generateMCparameters" uses
% for iSample = 1:nSamples
%     if (~isnan(funvals_martinb(iSample,1)) && ~isnan(funvals_martinb(iSample,3)))
%         paramMatrixMartinb(iSample,:) = generateMCparameters('gaussian',[funvals_martinb(iSample,1),funvals_martinb(iSample,3)],'plot',false);
%     end
% end
% iNonNanRows = find(all(~isnan(paramMatrixMartinb),2));
% paramMatrixMartinb = paramMatrixMartinb(iNonNanRows,:); % crop the NaN rows
% [midval_martinb_2,ci_martinb_2,funvals_martinb_2] = propagateErrorWithMC(@mean,paramMatrixMartinb,'plot',false);    
% 
% Method C
% [midval_martinb_3,ci_martinb_3,funvals_martinb_3] = propagateErrorWithMC(@mean,funvals_martinb(:,1)','plot',false);

end % errorPropagationWithMC

% *************************************************************************

end
